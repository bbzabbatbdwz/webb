'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.wrapAsyncMethods = wrapAsyncMethods;
exports.wrapSyncMethods = wrapSyncMethods;

var _object = require('./object');

/**
 * chrome api object
 * @see https://developer.chrome.com/extensions/api_index
 */
var chromeApi = getChromeApi();

/**
 * Create getters for async methods
 * @param {Object} obj
 * @param {String} namespace
 * @param {Array<String>} asyncMethods
 * @param {Function} Thenable
 * @returns {Object}
 */

function wrapAsyncMethods(obj, namespace, asyncMethods, Thenable) {
    if (asyncMethods === undefined) asyncMethods = [];

    return asyncMethods.reduce(function (result, method) {
        return appendAsyncMethod(obj, namespace, method, Thenable);
    }, obj);
}

/**
 * Wrap sync methods to promise
 * @param {Object} obj
 * @param {String} namespace
 * @param {Array<String>} syncMethods
 * @param {Function} Thenable
 * @returns {*}
 */

function wrapSyncMethods(obj, namespace, syncMethods, Thenable) {
    if (syncMethods === undefined) syncMethods = [];

    return syncMethods.reduce(function (result, method) {
        return appendSyncMethod(obj, namespace, method, Thenable);
    }, obj);
}

/**
 * Get chrome api object
 * @returns {chrome}
 */
function getChromeApi() {
    if (typeof window !== 'undefined' && window.chrome) {
        return window.chrome;
    }
    if (typeof global !== 'undefined' && global.chrome) {
        return global.chrome;
    }
}

/**
 * Append async method to data
 * @param {Object} obj
 * @param {String} namespace
 * @param {String} method
 * @param {Function} Thenable
 * @returns {Object}
 */
function appendAsyncMethod(obj, namespace, method, Thenable) {
    var data = (0, _object.get)(obj, namespace);
    Object.defineProperty(data, method, {
        get: function get() {
            return wrapAsyncMethod(Thenable, namespace, method);
        }
    });
    return obj;
}

/**
 * Wrap sync method
 * @param {Function} Thenable
 * @param {String} namespace
 * @param {String} method
 * @returns {Function}
 */
function wrapAsyncMethod(Thenable, namespace, method) {
    var _this = this;

    return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return new Thenable(function (resolve, reject) {
            var chromeNamespace = (0, _object.get)(chromeApi, namespace);
            args.push(getResolver(resolve, reject, _this));
            apply(chromeNamespace[method], chromeNamespace, args);
        });
    };
}

/**
 *
 * @param {Function} resolve
 * @param {Function} reject
 * @param {*} context
 * @returns {Function}
 */
function getResolver(resolve, reject, context) {
    return function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
        }

        if (chromeApi.runtime.lastError) {
            return reject(chromeApi.runtime.lastError);
        }
        return apply(resolve, context, args);
    };
}

/**
 * Append sync method
 * @param {Object} obj
 * @param {String} namespace
 * @param {String} method
 * @param {Function} PromiseConstructor
 * @returns {Object}
 */
function appendSyncMethod(obj, namespace, method, PromiseConstructor) {
    var data = (0, _object.get)(obj, namespace);
    Object.defineProperty(data, method, {
        get: function get() {
            return wrapSyncMethod(PromiseConstructor, namespace, method);
        }
    });
    return obj;
}

/**
 * Wrap sync method
 * @param {Function} Thenable
 * @param {String} namespace
 * @param {String} method
 * @returns {Function}
 */
function wrapSyncMethod(Thenable, namespace, method) {
    return function () {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
        }

        return new Thenable(function (resolve, reject) {
            var chromeNamespace = (0, _object.get)(chromeApi, namespace);
            try {
                return resolve(apply(chromeNamespace[method], chromeNamespace, args));
            } catch (e) {
                return reject(e);
            }
        });
    };
}

/**
 * For IE compatibility we can't use method.apply.
 *
 * Function apply
 * @param {Function} method
 * @param {*} context
 * @param {Array} args
 * @returns {*}
 */
function apply(method, context, args) {
    return Function.prototype.apply.call(method, context, args);
}